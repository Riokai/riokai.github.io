<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Kai's Blog]]></title>
  <subtitle><![CDATA[程序人生]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-03-30T03:47:25.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Kai]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[微信浏览器踩坑集锦]]></title>
    <link href="http://yoursite.com/2016/03/29/fucking-wechat/"/>
    <id>http://yoursite.com/2016/03/29/fucking-wechat/</id>
    <published>2016-03-29T02:22:40.000Z</published>
    <updated>2016-03-30T03:47:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>众所周知，微信浏览器（X5内核）被前端届称为移动端的“IE6”。最近发现自己的一个WebApp在微信下面出现一个坑爹的问题，所以想写一篇文章来总结一下自己在微信开发中所遇到的一些问题和解决办法，给自己和其它人提供参考。</p>
<p>先说一下微信浏览器的情况，安卓端微信6.1版本以上使用的是QQ浏览器X5的内核，5.4~6.1之间如果用户手机上安装过QQ浏览器，则使用X5内核。如果未安装，则使用系统浏览器内核。</p>
<p>iOS端的情况比较简单，由于苹果的限制，微信只能使用Safari提供的内核(也就是Webkit)。相对来说iOS的问题不多，问题主要集中在安卓端，也就是X5内核上面。<br><a id="more"></a></p>
<h2 id="坑">坑</h2><p>坑1：软键盘遮挡输入框</p>
<p>描述：这种情况发生在输入框位于底部时，点击输入框，键盘弹起，但是输入框却是纹丝不动，导致无法看到自己输出的内容。确认问题发生在微信版本号<code>v6.3.15</code>的机型上。</p>
<p>填坑：经过分析发现在这个bug只在微信上发现，与输入法无关，同时通过代码完全无法获取到键盘已经弹起还是下去的状态。目前的办法是判断当输入框<code>focus</code>时，判断视口是否发生变化，如果发生变化，则表示浏览器会自动调整输入框位置；如果无变化，则必须我们自己通过代码来调整输入框的位置。<code>focus</code>时调整高度，<code>blur</code>时恢复初始位置。但是由于我们无法获取软键盘确切的高度，所以有时候会出现输入框底部无法完美贴合软键盘。这个办法明显不够优雅，只能等待微信官方修复这个bug。</p>
<hr>
<p>坑2：缓存</p>
<p>描述：这个问题是老生常谈了，微信的缓存异常难清除，对于前端开发来说就像牛皮癣，修改的代码无变化，经常让前端开发者开始怀疑人生了。</p>
<p>填坑：通过给引用的资源文件后面添加时间戳可以基本解决这个问题，保证页面每次的刷新都是拿到最新的代码文件。在加上时间戳后再也没碰到缓存导致的问题，不过听说还有小伙伴使用这个办法后依然有缓存，这个时候我建议使用清除微信数据的办法（大招，慎用！）。</p>
<p><img src="/images/cache.png" alt="Cache"></p>
<hr>
<blockquote>
<p><a href="http://x5.tencent.com/doc?id=1002" target="_blank" rel="external">微信官方X5常见问题汇总</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>众所周知，微信浏览器（X5内核）被前端届称为移动端的“IE6”。最近发现自己的一个WebApp在微信下面出现一个坑爹的问题，所以想写一篇文章来总结一下自己在微信开发中所遇到的一些问题和解决办法，给自己和其它人提供参考。</p>
<p>先说一下微信浏览器的情况，安卓端微信6.1版本以上使用的是QQ浏览器X5的内核，5.4~6.1之间如果用户手机上安装过QQ浏览器，则使用X5内核。如果未安装，则使用系统浏览器内核。</p>
<p>iOS端的情况比较简单，由于苹果的限制，微信只能使用Safari提供的内核(也就是Webkit)。相对来说iOS的问题不多，问题主要集中在安卓端，也就是X5内核上面。<br>]]>
    
    </summary>
    
      <category term="collect" scheme="http://yoursite.com/tags/collect/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[疯狂动物城：你想要的它都有]]></title>
    <link href="http://yoursite.com/2016/03/13/zootopia/"/>
    <id>http://yoursite.com/2016/03/13/zootopia/</id>
    <published>2016-03-13T11:38:43.000Z</published>
    <updated>2016-03-30T03:32:44.000Z</updated>
    <content type="html"><![CDATA[<p>疯狂动物城，美好乌托邦。奇妙的想象，瑰丽的画面，悬疑、逆转、欢乐、感触……都有了。成年人看到政治讽刺和阶级偏见，青年人看到追求梦想，儿童看到可爱的动物。</p>
<p>通篇正能量，不放弃，懂坚持，有梦想，会追求。身体弱小的兔子警察有着不一般的梦想。即使被嘲笑，遇到挫折，仍坚持着，从处处不顺的训练，到手到擒来第一名证书，终于看似实现了自己的梦，成为了警察，兔子中唯一的警察。<br><a id="more"></a></p>
<p><img src="/images/zoo2.jpg" alt="Zoo"></p>
<p>挫折仅此而已吗？并不会是这样，走出自己小小的城市，来到大的市中心，动物城。却被蔑视，明明满腔热血想为民除害，然分配的任务只是贴罚单，当然这样并不能打击到我们的兔子警察。一上午200张，自强不息，给自己下任务，下目标。在逆境中成长，给自己的定位也并不仅仅是一个交通警察，遇到不平的事儿会帮助别人，被欺骗了会愤怒。以为自己做了一件好事，却以为的被上司批评，以为实现的梦想，其实并不那么简单。</p>
<p>每个人都有每个人的遭遇，第一次见到狐狸先生以为是一个疼爱子女的父亲，阴差阳错看清这个狐狸先生却只是一个奸商，虽愤怒却又无可奈何。意外的交集，不那么美丽的回忆。却因一个任务再次让狐狸先生和兔子警察联合在一起。</p>
<p>看似奸商的狐狸先生，其实小时候拥有着和兔子一样的梦，被别人践踏的梦，自己弱小到不得不正视自己的梦，一个自卑的梦或许就因为兔子和当时的自己一样弱小？让他能不遗余力的帮助这只兔子，从而让两只动物，成为合作无间的好拍档。</p>
<p>电影中树懒的出现是本剧最大的笑点！！！焦急的环境，飞逝的时间。。。只有树懒那慢吞吞的动作，一颦一笑都。好。慢。。特。别。慢。。。抬。头。。低。眸。。微。笑。。打。字。。有条理的，慢吞吞的做着工作。。。看着兔子警察对树懒慢吞吞工作的无奈，狐狸先生的狡黠，这段简直笑尿。</p>
<p><img src="/images/zoo.jpg" alt="Zoo"></p>
<p>最喜欢的部分还是朱迪一个人去大城市的部分，经过美丽的环境，带着美好的心情，配合着雀跃的歌曲，车子或上或下，这段旅程每一瞬都显得那么美丽。</p>
<p>电影制作精良，人物动作，表情都很精致，有着西方独特的性格。剧情方面就稍微显得薄弱，或者是通俗，没有啥太大的亮点。总体来说还是很赞的！寓意美好，很适合全家行的电影。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>疯狂动物城，美好乌托邦。奇妙的想象，瑰丽的画面，悬疑、逆转、欢乐、感触……都有了。成年人看到政治讽刺和阶级偏见，青年人看到追求梦想，儿童看到可爱的动物。</p>
<p>通篇正能量，不放弃，懂坚持，有梦想，会追求。身体弱小的兔子警察有着不一般的梦想。即使被嘲笑，遇到挫折，仍坚持着，从处处不顺的训练，到手到擒来第一名证书，终于看似实现了自己的梦，成为了警察，兔子中唯一的警察。<br>]]>
    
    </summary>
    
      <category term="Movie" scheme="http://yoursite.com/tags/Movie/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AngularJS特性研究之依赖注入]]></title>
    <link href="http://yoursite.com/2016/02/23/angular-dependency-injection/"/>
    <id>http://yoursite.com/2016/02/23/angular-dependency-injection/</id>
    <published>2016-02-23T06:19:53.000Z</published>
    <updated>2016-03-15T10:44:09.000Z</updated>
    <content type="html"><![CDATA[<p>说到AngularJS，大家都知道它有几个非常著名的特性，分别是：数据双向绑定、依赖注入(DI)、指令系统。这次我想来了解一下依赖注入背后的原理是怎样的。</p>
<h2 id="什么是依赖注入">什么是依赖注入</h2><p>依赖这个名词很好理解，就是我需要一个东西，这个东西并不是我自己的，而是来自其它地方的；注入则表示，现在我需要它，别人把这个东西呈给我。</p>
<a id="more"></a> 
<p>代码举例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// a.js</span><br><span class="line">function a() &#123;&#125;</span><br><span class="line"></span><br><span class="line">a.prototype.method = function() &#123; console.log('todo something'); &#125;</span><br><span class="line"></span><br><span class="line">// b.js</span><br><span class="line">require('a.js)</span><br><span class="line"></span><br><span class="line">a.method()</span><br></pre></td></tr></table></figure>
<p>当b文件需要使用a文件里的方法时，只需要通过require的方式将其引入进来。正确开发的时候不能这么写，这里只是起来解释什么是依赖注入。</p>
<h2 id="依赖注入的好处">依赖注入的好处</h2><p>依赖注入是一种设计模式，它移除了硬编码依赖，因此使得我们可以在运行中随时移除并改变依赖项目。</p>
<p>在运行过程中能够修改依赖项目的能力允许我们创建隔离环境，这对于测试来说是非常理想的。我们可以用测试环境中的一个冒牌对象来替换生产环境中的一个真实对象。</p>
<p>从功能上来说，这种模式通过自动提前查找依赖以及为依赖提供目标，以此将依赖资源注入到需要它们的地方。</p>
<h2 id="Angular中的依赖注入">Angular中的依赖注入</h2><p>下面让我们来看看AngularJS中如何使用依赖注入的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FirstController = ($scope) =&gt; &#123;</span><br><span class="line">	$scope.a = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码只要是有点Angular基础的都很容易看懂，FirstController控制器需要使用$scope，看起来貌似挺正常。</p>
<p>再来一个示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FirstController = ($scope, $http) =&gt; &#123;</span><br><span class="line">	$scope.a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	$http.get(<span class="string">'url'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FirstController()</span><br></pre></td></tr></table></figure>
<p>代码比原来增加了一个$http服务，这个时候问题来了，如果此时我们调用FirstController会发生什么呢？不用想，肯定会报错。但是在AngularJS的世界里，它会知道此时需要传入$scope和$http，并且正确的将其传入。这就是Angular的依赖注入机制，我们可以试着来模拟一下，Let’s do it。</p>
<h2 id="模拟Angular依赖注入">模拟Angular依赖注入</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FirstController = ($scope,$http) =&gt; &#123;</span><br><span class="line">	$scope.a = <span class="number">1</span>;</span><br><span class="line">	$http.get(<span class="string">''</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖注入器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Injector</span> </span>&#123;</span><br><span class="line">	constructor() &#123;</span><br><span class="line">		<span class="keyword">this</span>.dependencies = &#123;&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	register(key, value) &#123;</span><br><span class="line">		<span class="keyword">this</span>.dependencies[key] = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	resolve(deps, controller) &#123;</span><br><span class="line">		<span class="keyword">let</span> arr = [];</span><br><span class="line"></span><br><span class="line">		deps.forEach(dep =&gt; &#123;</span><br><span class="line">			<span class="comment">// 判断该模块是否被注册</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.dependencies.hasOwnProperty(dep)) &#123;</span><br><span class="line">				arr.push(<span class="keyword">this</span>.dependencies[dep]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> () =&gt; &#123;</span><br><span class="line">			controller.apply(&#123;&#125;, arr);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里创建了里面injector，dependencies对象用来保存通过injector注册的模块，register方法实现注册模块，resolve方法用于为控制器注入所需的依赖。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> injector = <span class="keyword">new</span> Injector();</span><br><span class="line"></span><br><span class="line">injector.register(<span class="string">'$http'</span>, &#123;<span class="string">'get'</span>: value =&gt; <span class="built_in">console</span>.log(value);&#125;);</span><br><span class="line">injector.register(<span class="string">'$scope'</span>, &#123;<span class="string">'a'</span>:<span class="string">''</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>我们先注册几个模块，Angular在其内部也实现了这个过程。</p>
<p>现在可以开始注入了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> FirstController = ($scope,$http) =&gt; &#123;</span><br><span class="line">	$scope.a = <span class="number">1</span>;</span><br><span class="line">	$http.get(<span class="string">'load data successful'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FirstController = injector.resolve([<span class="string">'$scope'</span>, <span class="string">'$http'</span>], FirstController);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Run Controller</span></span><br><span class="line">FirstController();</span><br></pre></td></tr></table></figure>
<p>运行正常，我们得到了意料的结果。<br><img src="/images/DI.png" alt="DI"></p>
<p>不过，这并没有结束，现在还有两个问题需要我们解决</p>
<ul>
<li>如果resolve中传入的deps顺序有误怎么办？</li>
<li>写书写AnuglarJS代码时候，不需要我们去resolve</li>
</ul>
<p>通过翻看Angular的源代码，发现了它的解决办法：<strong>将函数代码字符串化，然后通过正则匹配出需要的依赖。</strong></p>
<p>但是具体是怎么实现呢？我们继续改造injector！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">resolve(controller) &#123;</span><br><span class="line">	<span class="keyword">let</span> FN_ARGS = <span class="regexp">/^\s*[^\(]*\(\s*([^\)]*)\)/m</span>;</span><br><span class="line">	<span class="keyword">let</span> STRIP_COMMENTS = <span class="regexp">/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg</span>;</span><br><span class="line">	<span class="keyword">let</span> fnText = controller.toString().replace(STRIP_COMMENTS, <span class="string">''</span>);</span><br><span class="line">	<span class="keyword">let</span> argDecl = fnText.match(FN_ARGS);</span><br><span class="line">	<span class="keyword">let</span> deps = argDecl[<span class="number">1</span>].split(<span class="string">','</span>);</span><br><span class="line">	<span class="keyword">let</span> arr = [];</span><br><span class="line"></span><br><span class="line">	deps.forEach(dep =&gt; &#123;</span><br><span class="line">		<span class="comment">// 判断该模块是否被注册</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.dependencies.hasOwnProperty(dep)) &#123;</span><br><span class="line">			arr.push(<span class="keyword">this</span>.dependencies[dep]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> () =&gt; &#123;</span><br><span class="line">		controller.apply(&#123;&#125;, arr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改造后的resolve不再需要我们传依赖数据，而是自己得出依赖并且自动注入</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FirstController = injector.resolve(FirstController);</span><br></pre></td></tr></table></figure>
<p>不再传入数组，仅仅传入一个控制器，可以看到结果依然是正确的。</p>
<p><img src="/images/DI2.png" alt="DI"></p>
<h2 id="总结">总结</h2><p>写到这里，实现了一个微型的Injector，然而Angular背后的实现原比这个要复杂的多。如果文章中有什么写的不对的地方，欢迎指正。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>说到AngularJS，大家都知道它有几个非常著名的特性，分别是：数据双向绑定、依赖注入(DI)、指令系统。这次我想来了解一下依赖注入背后的原理是怎样的。</p>
<h2 id="什么是依赖注入">什么是依赖注入</h2><p>依赖这个名词很好理解，就是我需要一个东西，这个东西并不是我自己的，而是来自其它地方的；注入则表示，现在我需要它，别人把这个东西呈给我。</p>]]>
    
    </summary>
    
      <category term="AngularJS" scheme="http://yoursite.com/tags/AngularJS/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTML5 Web Notifications解析]]></title>
    <link href="http://yoursite.com/2015/07/16/html5-notification/"/>
    <id>http://yoursite.com/2015/07/16/html5-notification/</id>
    <published>2015-07-15T21:20:00.000Z</published>
    <updated>2016-03-15T10:44:40.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1、_为什么要有Web_Notification">1、 为什么要有Web Notification</h2><p>过去网站给用户发送提醒的方式一般是写一个div放在右下角，通过AJax不断请求后台来获取推送消息。这种方式的问题在于如果用户的活动窗口是其它页面，用户并不能发现有一条推送消息。比如你打开了GMail，但你这个时间在天猫上浏览器商品，如果这时候来了一封邮件你是无法知道。而Web Notification正是为解决这个问题而诞生的。通过Web Notification发送的提醒可以无视当前活动窗口是哪个，只要浏览器是运行的，用户都能在一个明显的地方看到通知。<br><a id="more"></a> </p>
<h2 id="2、_一条Notification的生命周期">2、 一条Notification的生命周期</h2><ul>
<li>1、检查浏览器是否支持Web Notifications</li>
<li>2、检查该网站是否已经获取通知权限，若没有，则弹出权限请求提醒</li>
<li>3、创建消息</li>
<li>4、显示消息</li>
<li>5、手动，自动关闭消息</li>
</ul>
<h2 id="3、_API">3、 API</h2><h3 id="3-1_构造函数">3.1 构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Notification.Notification()</span><br></pre></td></tr></table></figure>
<h3 id="3-2_属性">3.2 属性</h3><h4 id="3-2-1_静态属性">3.2.1 静态属性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Notification.permission</span><br></pre></td></tr></table></figure>
<p>属性的值有3种：<br>  default：permission的默认值，表示网站还没有请求过发送通知的权限或者发送过但被用户忽略<br>  granted：表示网站已经获取到发送通知的权限<br>  denied：表示拒绝网站向用户发送通知消息</p>
<h4 id="3-2-2_实例属性">3.2.2 实例属性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Notification.title</span><br></pre></td></tr></table></figure>
<p>通知的标题<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Notification.dir</span><br></pre></td></tr></table></figure></p>
<p>通知出现的方向<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Notification.lang</span><br></pre></td></tr></table></figure></p>
<p>通知的语言<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Notification.body</span><br></pre></td></tr></table></figure></p>
<p>通知的主体<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Notification.icon</span><br></pre></td></tr></table></figure></p>
<p>通知的图标<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Notification.slient</span><br></pre></td></tr></table></figure></p>
<h2 id="4、参考文档">4、参考文档</h2><p><a href="http://www.w3.org/TR/notifications/" target="_blank" rel="external">W3 Web Notifications</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/notification" target="_blank" rel="external">MDN Notifications</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1、_为什么要有Web_Notification">1、 为什么要有Web Notification</h2><p>过去网站给用户发送提醒的方式一般是写一个div放在右下角，通过AJax不断请求后台来获取推送消息。这种方式的问题在于如果用户的活动窗口是其它页面，用户并不能发现有一条推送消息。比如你打开了GMail，但你这个时间在天猫上浏览器商品，如果这时候来了一封邮件你是无法知道。而Web Notification正是为解决这个问题而诞生的。通过Web Notification发送的提醒可以无视当前活动窗口是哪个，只要浏览器是运行的，用户都能在一个明显的地方看到通知。<br>]]>
    
    </summary>
    
      <category term="HTML5" scheme="http://yoursite.com/tags/HTML5/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
  </entry>
  
</feed>
